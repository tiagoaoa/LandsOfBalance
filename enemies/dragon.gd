class_name Dragon
extends CharacterBody3D

## Ancient Dragon that patrols the map flying, lands on hills, and attacks nearby players
## Network-synchronized across all players.
##
## Behavior:
## - Flies in oval patrol pattern around player start area
## - After 2 laps, flies to and lands on the main hill
## - Waits for 5 seconds (idle animation)
## - Takes off and resumes patrol
## - Attacks player if within range while landed

const DragonWingFlapClass := preload("res://enemies/dragon_wing_flap.gd")

# Use Protocol.DragonState for network sync compatibility
const Proto = preload("res://multiplayer/protocol.gd")
const DragonState = Proto.DragonState

signal lap_completed(lap_number: int)
signal state_changed(new_state: int)

# Network synchronization
var entity_id: int = 0
var health: float = 500.0  # Dragon has more health
var _is_network_controlled: bool = false
var _target_position: Vector3 = Vector3.ZERO
var _target_rotation: float = 0.0
var lap_count: int = 0  # For network sync

# Patrol settings (scaled for large dragon)
@export var patrol_radius: float = 8000.0  # Radius of patrol circle (covers entire map)
@export var patrol_height: float = 90.0   # Flying height above ground (10m higher)
@export var patrol_speed: float = 25.0    # Base flying speed
@export var laps_before_landing: int = 2  # Land after this many laps

# Landing settings
@export var landing_spot: Vector3 = Vector3(0, 5, 50)  # Where to land (top of hill)
@export var wait_time: float = 5.0  # Seconds to wait when landed

# Combat settings
@export var attack_range: float = 40.0    # Distance to trigger attack when landed
@export var detection_range: float = 100.0  # Distance to detect player

# State
var state: int = DragonState.PATROL:
	set(value):
		var old_state := state
		state = value
		if old_state != state:
			state_changed.emit(state)
			print("Dragon state: ", Proto.DragonState.keys()[state])

var patrol_angle: float = 0.0  # Current angle in circular patrol
var patrol_center: Vector3 = Vector3.ZERO
var laps_completed: int = 0
var wait_timer: float = 0.0
var target_player: Node3D = null

# Orientation tracking for smooth banking
var _last_direction: Vector3 = Vector3.FORWARD
var _current_bank_angle: float = 0.0
var _target_basis: Basis = Basis.IDENTITY

# Flight physics - gravity and lift from wing flaps
var _vertical_velocity: float = 0.0
var _forward_speed_multiplier: float = 1.0  # Current forward speed as multiplier of patrol_speed
const FLIGHT_GRAVITY: float = 15.0  # Gravity during flight (lighter than ground gravity)
const WING_LIFT_FORCE: float = 35.0  # Lift generated by wing downstroke
const WING_THRUST_FORCE: float = 0.8  # Forward thrust from wing downstroke (multiplier boost)
const AIR_DRAG: float = 2.0  # Air resistance slows dragon during upstroke
const FLAP_DURATION: float = 1.2  # Duration of one wing flap cycle (matches animation)

# Components
var _model: Node3D
var _anim_player: AnimationPlayer
var _anim_tree: AnimationTree
var _skeleton: Skeleton3D
var _mouth_fire: Node3D
var _mouth_light: OmniLight3D
var _mouth_bone_idx: int = -1

# Animation names (Elder Scrolls Blades dragon)
var anim_fly: StringName = &""
var anim_idle: StringName = &""
var anim_attack: StringName = &""
var anim_land: StringName = &""
var anim_takeoff: StringName = &""

@onready var gravity: float = ProjectSettings.get_setting("physics/3d/default_gravity")


func _ready() -> void:
	# Load and setup dragon model
	_setup_dragon_model()

	# Add collision shape
	_setup_collision()

	# Set initial position - center patrol on player start position
	patrol_center = Vector3(0, 0, 10)  # Player starts at (0, 1, 10)
	patrol_angle = 0.0
	position = _get_patrol_position()

	# Find player
	await get_tree().process_frame
	_find_player()

	# Setup network
	_setup_network()

	print("Dragon ready! Animations found: ", _get_animation_list())


func _setup_network() -> void:
	# Use fixed entity ID = 2 for Dragon (Bobba is 1, Dragon is 2)
	# Server spawns entities with incrementing IDs starting from 1
	entity_id = 2

	# Register with NetworkManager if available
	var network_manager = get_node_or_null("/root/NetworkManager")
	if network_manager:
		network_manager.register_entity(self, Proto.EntityType.ENTITY_DRAGON, entity_id)

		# Connect to connection signals to update mode when connection state changes
		if not network_manager.connected_to_server.is_connected(_on_connected_to_server):
			network_manager.connected_to_server.connect(_on_connected_to_server)
		if not network_manager.joined_game.is_connected(_on_joined_game):
			network_manager.joined_game.connect(_on_joined_game)
		if not network_manager.spectating_started.is_connected(_on_spectating_started):
			network_manager.spectating_started.connect(_on_spectating_started)

		# Check connection status immediately
		_update_network_control_mode()
	else:
		# No NetworkManager - run locally
		_is_network_controlled = false
		print("Dragon [%d]: Locally-controlled (no NetworkManager)" % entity_id)


func _on_connected_to_server() -> void:
	_update_network_control_mode()


func _on_joined_game() -> void:
	_update_network_control_mode()


func _on_spectating_started() -> void:
	_update_network_control_mode()


func _update_network_control_mode() -> void:
	var network_manager = get_node_or_null("/root/NetworkManager")
	if not network_manager:
		return

	# Server is ALWAYS authoritative for entities - all clients receive state from server
	var is_connected = network_manager.client_state and network_manager.client_state.is_network_connected()
	var is_spectating = network_manager.is_spectating

	if is_connected or is_spectating:
		if not _is_network_controlled:
			_is_network_controlled = true
			print("Dragon [%d]: Network-controlled (server authoritative)" % entity_id)
	else:
		if _is_network_controlled:
			_is_network_controlled = false
			print("Dragon [%d]: Locally-controlled (single player)" % entity_id)


func _exit_tree() -> void:
	# Unregister from NetworkManager
	if has_node("/root/NetworkManager"):
		var network_manager = get_node("/root/NetworkManager")
		if network_manager.has_method("unregister_entity"):
			network_manager.unregister_entity(entity_id)


func _setup_dragon_model() -> void:
	# Load the dragon GLB
	var dragon_scene: PackedScene = load("res://assets/dragon.glb") as PackedScene
	if dragon_scene == null:
		push_error("Dragon: Failed to load dragon.glb")
		return

	_model = dragon_scene.instantiate()
	_model.name = "DragonModel"
	add_child(_model)

	# Scale dragon appropriately (30% smaller than before)
	_model.scale = Vector3(35.0, 35.0, 35.0)

	# Find Skeleton for mouth fire attachment
	_skeleton = _find_skeleton(_model)
	if _skeleton:
		_setup_mouth_fire()

	# Find AnimationPlayer
	_anim_player = _find_animation_player(_model)
	if _anim_player:
		_anim_player.animation_finished.connect(_on_animation_finished)
		# Create procedural wing flap animation for flying
		DragonWingFlapClass.add_to_animation_player(_anim_player, &"WingFlap")
		_detect_animations()
		print("Dragon AnimationPlayer found with ", _anim_player.get_animation_list().size(), " animations")
	else:
		push_warning("Dragon: No AnimationPlayer found")


func _setup_collision() -> void:
	# Check if collision shape already exists (added in scene file)
	var existing_collision := get_node_or_null("CollisionShape3D")
	if existing_collision:
		print("Dragon: Using existing collision shape from scene")
	else:
		# Create collision shape for the dragon body using ConvexPolygonShape3D
		var collision := CollisionShape3D.new()
		collision.name = "CollisionShape3D"

		# Create a convex polygon shape that roughly matches dragon silhouette
		var shape := ConvexPolygonShape3D.new()

		# Define vertices for a dragon-shaped convex hull (scaled for 35.0 model scale)
		# Body is roughly 280m long, 105m wide, 140m tall
		var s := 70.0  # Scale factor (35.0 / 0.5 = 70)
		var points := PackedVector3Array([
			# Body front (head area)
			Vector3(0.0, 1.0, 2.5) * s,      # Nose tip
			Vector3(-0.4, 0.8, 2.0) * s,     # Head left
			Vector3(0.4, 0.8, 2.0) * s,      # Head right
			Vector3(0.0, 1.5, 1.5) * s,      # Head top

			# Body middle (torso)
			Vector3(-1.0, 0.5, 0.0) * s,     # Body left bottom
			Vector3(1.0, 0.5, 0.0) * s,      # Body right bottom
			Vector3(-1.2, 1.5, 0.0) * s,     # Body left top
			Vector3(1.2, 1.5, 0.0) * s,      # Body right top
			Vector3(0.0, 2.0, 0.0) * s,      # Back ridge

			# Wing attachment points (widest part)
			Vector3(-2.5, 1.0, -0.5) * s,    # Left wing root
			Vector3(2.5, 1.0, -0.5) * s,     # Right wing root

			# Body rear (hip area)
			Vector3(-0.8, 0.5, -1.5) * s,    # Rear left bottom
			Vector3(0.8, 0.5, -1.5) * s,     # Rear right bottom
			Vector3(-0.6, 1.2, -1.5) * s,    # Rear left top
			Vector3(0.6, 1.2, -1.5) * s,     # Rear right top

			# Tail base
			Vector3(0.0, 0.8, -2.5) * s,     # Tail tip
		])

		shape.points = points
		collision.shape = shape
		# Center the collision shape on the dragon's body
		# Model is upright now, so offset up by roughly half the body height
		collision.position = Vector3(0, 70.0, 0)

		add_child(collision)

	# Set collision layers - dragon is on layer 2 (enemies)
	collision_layer = 2
	collision_mask = 1  # Collides with layer 1 (player/world)


func _find_animation_player(node: Node) -> AnimationPlayer:
	if node is AnimationPlayer:
		return node as AnimationPlayer
	for child in node.get_children():
		var result := _find_animation_player(child)
		if result:
			return result
	return null


func _find_skeleton(node: Node) -> Skeleton3D:
	if node is Skeleton3D:
		return node as Skeleton3D
	for child in node.get_children():
		var result := _find_skeleton(child)
		if result:
			return result
	return null


func _setup_mouth_fire() -> void:
	## Create intense fire effect at dragon's mouth - always ready to breathe fire
	## Visible from far away in darkness, illuminates dragon's face

	# Find the head/jaw bone for positioning
	# Dragon bones: NPC Head_045 or NPC Jaw_046 (after neck bones 040-044)
	for i in _skeleton.get_bone_count():
		var bone_name := _skeleton.get_bone_name(i)
		if "Head" in bone_name or "Jaw" in bone_name:
			_mouth_bone_idx = i
			print("Dragon: Found mouth bone '%s' at index %d" % [bone_name, i])
			break

	# If no head bone found, use last neck bone
	if _mouth_bone_idx < 0:
		for i in _skeleton.get_bone_count():
			var bone_name := _skeleton.get_bone_name(i)
			if "Neck5" in bone_name:
				_mouth_bone_idx = i
				print("Dragon: Using Neck5 bone for mouth fire at index %d" % i)
				break

	# Create fire container (will be positioned each frame)
	_mouth_fire = Node3D.new()
	_mouth_fire.name = "MouthFire"
	add_child(_mouth_fire)

	# === MAIN FIRE PARTICLES - Intense orange-red flames ===
	var fire_particles := GPUParticles3D.new()
	fire_particles.name = "FireParticles"
	fire_particles.amount = 120
	fire_particles.lifetime = 0.6
	fire_particles.explosiveness = 0.1
	fire_particles.randomness = 0.5

	var fire_material := ParticleProcessMaterial.new()
	fire_material.direction = Vector3(0, 0, -1)  # Forward from mouth
	fire_material.spread = 25.0
	fire_material.initial_velocity_min = 3.0
	fire_material.initial_velocity_max = 8.0
	fire_material.gravity = Vector3(0, 4.0, 0)  # Fire rises
	fire_material.scale_min = 0.8
	fire_material.scale_max = 2.0

	# Intense fire color gradient with more RED
	var color_ramp := GradientTexture1D.new()
	var gradient := Gradient.new()
	gradient.add_point(0.0, Color(1.0, 1.0, 0.7, 1.0))   # Bright white-yellow core
	gradient.add_point(0.2, Color(1.0, 0.9, 0.3, 1.0))   # Intense yellow
	gradient.add_point(0.4, Color(1.0, 0.5, 0.0, 1.0))   # Orange
	gradient.add_point(0.7, Color(1.0, 0.2, 0.0, 0.9))   # Deep orange-red
	gradient.add_point(1.0, Color(0.8, 0.0, 0.0, 0.0))   # Red fade out
	color_ramp.gradient = gradient
	fire_material.color_ramp = color_ramp

	fire_material.emission_shape = ParticleProcessMaterial.EMISSION_SHAPE_SPHERE
	fire_material.emission_sphere_radius = 1.5

	fire_particles.process_material = fire_material

	# Fire mesh (billboard quad)
	var fire_mesh := QuadMesh.new()
	fire_mesh.size = Vector2(2.5, 2.5)

	var fire_mesh_material := StandardMaterial3D.new()
	fire_mesh_material.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA
	fire_mesh_material.shading_mode = BaseMaterial3D.SHADING_MODE_UNSHADED
	fire_mesh_material.billboard_mode = BaseMaterial3D.BILLBOARD_ENABLED
	fire_mesh_material.albedo_color = Color(1.0, 0.7, 0.3, 0.9)
	fire_mesh_material.emission_enabled = true
	fire_mesh_material.emission = Color(1.0, 0.4, 0.1)
	fire_mesh_material.emission_energy_multiplier = 8.0
	fire_mesh.material = fire_mesh_material

	fire_particles.draw_pass_1 = fire_mesh
	_mouth_fire.add_child(fire_particles)

	# === EMBER/SPARK PARTICLES - Red hot embers ===
	var ember_particles := GPUParticles3D.new()
	ember_particles.name = "EmberParticles"
	ember_particles.amount = 40
	ember_particles.lifetime = 1.2
	ember_particles.explosiveness = 0.2
	ember_particles.randomness = 0.8

	var ember_material := ParticleProcessMaterial.new()
	ember_material.direction = Vector3(0, 1, -0.5)
	ember_material.spread = 45.0
	ember_material.initial_velocity_min = 2.0
	ember_material.initial_velocity_max = 6.0
	ember_material.gravity = Vector3(0, 1.0, 0)
	ember_material.scale_min = 0.2
	ember_material.scale_max = 0.5

	var ember_gradient := Gradient.new()
	ember_gradient.add_point(0.0, Color(1.0, 0.8, 0.3, 1.0))  # Bright spark
	ember_gradient.add_point(0.5, Color(1.0, 0.3, 0.0, 0.8))  # Orange
	ember_gradient.add_point(1.0, Color(0.6, 0.0, 0.0, 0.0))  # Dark red fade
	var ember_ramp := GradientTexture1D.new()
	ember_ramp.gradient = ember_gradient
	ember_material.color_ramp = ember_ramp
	ember_material.emission_shape = ParticleProcessMaterial.EMISSION_SHAPE_SPHERE
	ember_material.emission_sphere_radius = 2.0

	ember_particles.process_material = ember_material

	var ember_mesh := QuadMesh.new()
	ember_mesh.size = Vector2(0.6, 0.6)
	var ember_mesh_mat := StandardMaterial3D.new()
	ember_mesh_mat.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA
	ember_mesh_mat.shading_mode = BaseMaterial3D.SHADING_MODE_UNSHADED
	ember_mesh_mat.billboard_mode = BaseMaterial3D.BILLBOARD_ENABLED
	ember_mesh_mat.albedo_color = Color(1.0, 0.5, 0.2, 1.0)
	ember_mesh_mat.emission_enabled = true
	ember_mesh_mat.emission = Color(1.0, 0.3, 0.0)
	ember_mesh_mat.emission_energy_multiplier = 6.0
	ember_mesh.material = ember_mesh_mat

	ember_particles.draw_pass_1 = ember_mesh
	_mouth_fire.add_child(ember_particles)

	# === MAIN LIGHT - Intense orange-red glow visible from far away ===
	_mouth_light = OmniLight3D.new()
	_mouth_light.name = "MouthFireLight"
	_mouth_light.light_color = Color(1.0, 0.4, 0.1)  # Orange-red
	_mouth_light.light_energy = 800.0  # Very intense for visibility
	_mouth_light.omni_range = 25.0  # Large range to illuminate dragon and surroundings
	_mouth_light.omni_attenuation = 1.2
	_mouth_light.shadow_enabled = true
	_mouth_fire.add_child(_mouth_light)

	# === SECONDARY FILL LIGHT - Softer red for atmosphere ===
	var fill_light := OmniLight3D.new()
	fill_light.name = "FillLight"
	fill_light.light_color = Color(1.0, 0.2, 0.0)  # Deep red
	fill_light.light_energy = 300.0
	fill_light.omni_range = 40.0  # Even larger for distant visibility
	fill_light.omni_attenuation = 1.5
	fill_light.shadow_enabled = false
	_mouth_fire.add_child(fill_light)

	# Start light flickering
	_start_mouth_fire_flicker()

	print("Dragon: Mouth fire effect created")


func _start_mouth_fire_flicker() -> void:
	## Create realistic fire flicker effect on mouth light
	if not _mouth_light or not is_inside_tree():
		return

	var flicker_tween := create_tween()
	flicker_tween.set_loops()
	flicker_tween.tween_property(_mouth_light, "light_energy", 900.0, 0.08)
	flicker_tween.tween_property(_mouth_light, "light_energy", 700.0, 0.12)
	flicker_tween.tween_property(_mouth_light, "light_energy", 850.0, 0.06)
	flicker_tween.tween_property(_mouth_light, "light_energy", 750.0, 0.1)
	flicker_tween.tween_property(_mouth_light, "light_energy", 950.0, 0.05)
	flicker_tween.tween_property(_mouth_light, "light_energy", 650.0, 0.15)


func _update_mouth_fire_position() -> void:
	## Position mouth fire at the dragon's head bone each frame
	if not _mouth_fire or not _skeleton or _mouth_bone_idx < 0:
		return

	# Get head bone global position
	var bone_pose := _skeleton.get_bone_global_pose(_mouth_bone_idx)
	var bone_global := _skeleton.global_transform * bone_pose

	# Position fire slightly in front of the mouth (forward direction)
	# Offset forward based on dragon's facing direction
	var forward_offset := -_model.global_transform.basis.z * 8.0  # Forward from head
	var up_offset := Vector3(0, 2.0, 0)  # Slightly above

	_mouth_fire.global_position = bone_global.origin + forward_offset + up_offset


func _detect_animations() -> void:
	if not _anim_player:
		return

	var anims := _get_animation_list()
	print("Dragon animations: ", anims)

	# Use our procedural WingFlap animation for flying
	if _anim_player.has_animation(&"WingFlap"):
		anim_fly = &"WingFlap"
		print("Dragon: Using procedural WingFlap animation for flying")

	# Try to match animations by common naming patterns
	for anim_name in anims:
		var lower := anim_name.to_lower()

		if anim_fly == &"" and ("fly" in lower or "glide" in lower or "hover" in lower):
			anim_fly = anim_name
		elif lower.ends_with("patrol_idle"):  # Prefer base patrol_idle (not random variants)
			anim_idle = anim_name
		elif "idle" in lower and "fly" not in lower and "recoil" not in lower:
			if anim_idle == &"":  # Only if not already set
				anim_idle = anim_name
		elif "powerattack" in lower or "power_attack" in lower:
			anim_attack = anim_name  # Prioritize power attack
		elif ("attack" in lower or "bite" in lower) and anim_attack == &"":
			anim_attack = anim_name
		elif "land" in lower and "take" not in lower:
			anim_land = anim_name
		elif "take" in lower and "off" in lower:
			anim_takeoff = anim_name

	# Fallbacks - use first animation containing keywords
	if anim_fly == &"":
		for anim_name in anims:
			if "fly" in anim_name.to_lower():
				anim_fly = anim_name
				break

	if anim_idle == &"":
		for anim_name in anims:
			if "idle" in anim_name.to_lower():
				anim_idle = anim_name
				break

	# If still no fly animation, use idle as fallback
	if anim_fly == &"" and anim_idle != &"":
		anim_fly = anim_idle

	print("Detected - Fly: ", anim_fly, ", Idle: ", anim_idle, ", Attack: ", anim_attack)


func _get_animation_list() -> PackedStringArray:
	var result := PackedStringArray()
	if not _anim_player:
		return result

	for lib_name in _anim_player.get_animation_library_list():
		var lib := _anim_player.get_animation_library(lib_name)
		for anim_name in lib.get_animation_list():
			if lib_name == &"":
				result.append(anim_name)
			else:
				result.append(str(lib_name) + "/" + str(anim_name))

	return result


func _find_player() -> void:
	# Find player in the scene
	var players := get_tree().get_nodes_in_group("player")
	if players.size() > 0:
		target_player = players[0]
	else:
		# Try to find by class name
		for node in get_tree().get_nodes_in_group(""):
			if node is CharacterBody3D and node.name == "Player":
				target_player = node
				break

		# Last resort - find any Player node
		if target_player == null:
			target_player = get_tree().root.find_child("Player", true, false)


func _get_patrol_position() -> Vector3:
	# Oval patrol path with slight height variation for realism
	var x := patrol_center.x + cos(patrol_angle) * patrol_radius
	var z := patrol_center.z + sin(patrol_angle) * patrol_radius * 0.7  # Oval shape
	var y := patrol_height + sin(patrol_angle * 2) * 1.5  # Gentle undulation
	return Vector3(x, y, z)


func _physics_process(delta: float) -> void:
	# Network-controlled mode: interpolate to received position
	if _is_network_controlled:
		_handle_network_interpolation(delta)
		_update_mouth_fire_position()
		return

	# TEST_MULTIPLAYER mode: just patrol, no attacks
	if GameSettings and GameSettings.test_multiplayer:
		_process_patrol(delta)
		_update_mouth_fire_position()
		return

	# Host controls the dragon AI
	match state:
		DragonState.PATROL:
			_process_patrol(delta)
		DragonState.FLYING_TO_LAND:
			_process_flying_to_land(delta)
		DragonState.LANDING:
			_process_landing(delta)
		DragonState.WAIT:
			_process_wait(delta)
		DragonState.TAKING_OFF:
			_process_takeoff(delta)
		DragonState.ATTACKING:
			_process_attacking(delta)

	# Update lap_count for network sync
	lap_count = laps_completed

	move_and_slide()

	# Update mouth fire to follow head bone
	_update_mouth_fire_position()


## Handle interpolation for network-controlled entities
func _handle_network_interpolation(delta: float) -> void:
	const INTERP_SPEED = 8.0

	# Smoothly interpolate to target position
	global_position = global_position.lerp(_target_position, INTERP_SPEED * delta)

	# Interpolate rotation
	if _model:
		_model.rotation.y = lerp_angle(_model.rotation.y, _target_rotation, INTERP_SPEED * delta)

	move_and_slide()


## Get network state for synchronization
func get_network_state() -> int:
	return state


## Get facing rotation (model rotation for network sync)
func get_facing_rotation() -> float:
	if _model:
		return _model.rotation.y
	return rotation.y


## Apply network state received from host
func apply_network_state(data: Dictionary) -> void:
	if not _is_network_controlled:
		return

	_target_position = data.get("position", global_position)
	_target_rotation = data.get("rotation_y", _target_rotation)

	var new_state = data.get("state", state)
	if new_state != state:
		state = new_state
		_update_animation_for_state()

	health = data.get("health", health)

	# Extra data for dragon
	lap_count = data.get("extra1", lap_count)
	patrol_angle = data.get("extra2", patrol_angle)


## Update animation to match current state
func _update_animation_for_state() -> void:
	match state:
		DragonState.PATROL, DragonState.FLYING_TO_LAND, DragonState.TAKING_OFF:
			_play_animation(anim_fly, true)
		DragonState.LANDING:
			_play_animation(anim_land, false)
		DragonState.WAIT:
			_play_animation(anim_idle, true)
		DragonState.ATTACKING:
			_play_animation(anim_attack, false)


func _process_patrol(delta: float) -> void:
	# Play fly animation
	_play_animation(anim_fly, true)

	# Move along circular patrol path
	patrol_angle += (patrol_speed / patrol_radius) * delta

	# Check for lap completion
	if patrol_angle >= TAU:
		patrol_angle -= TAU
		laps_completed += 1
		lap_completed.emit(laps_completed)
		print("Dragon completed lap ", laps_completed)

		# Land after specified number of laps
		if laps_completed >= laps_before_landing:
			laps_completed = 0
			state = DragonState.FLYING_TO_LAND
			return

	# Move towards patrol position
	var target_pos := _get_patrol_position()
	var direction := (target_pos - position).normalized()

	# Apply flight physics - gravity, lift, and forward thrust from wing flaps
	_apply_flight_physics(delta, target_pos.y)

	# Horizontal movement towards patrol position (speed varies with wing flaps)
	var current_speed := patrol_speed * _forward_speed_multiplier
	velocity.x = direction.x * current_speed
	velocity.z = direction.z * current_speed
	velocity.y = _vertical_velocity

	# Rotate dragon to face movement direction
	_face_direction(direction, delta)


func _apply_flight_physics(delta: float, target_height: float) -> void:
	## Apply gravity, lift, and forward thrust synchronized with wing flaps
	## Creates natural flight motion: up+forward on downstroke, sink+slow on upstroke
	##
	## Physics model:
	## - Constant gravity pulls dragon down
	## - Wings generate lift AND forward thrust during downstroke (0-40% of cycle)
	## - Air resistance slows dragon during upstroke (0.4-1.0)
	## - Net effect: dragon bobs up and surges forward on downstroke,
	##   then sinks and slows during upstroke

	# Get current position in wing flap cycle (0.0 to 1.0)
	var flap_phase := _get_wing_flap_phase()

	# Calculate force multiplier based on flap phase
	# Downstroke (0.0 to 0.4): Maximum lift and thrust - wings push air down and back
	# Upstroke (0.4 to 1.0): Minimal lift, air resistance dominates
	var lift_multiplier: float
	var thrust_multiplier: float
	var drag_multiplier: float

	if flap_phase < 0.4:
		# Downstroke: strong lift and thrust, peaks at mid-downstroke
		var downstroke_progress := flap_phase / 0.4  # 0 to 1 during downstroke
		var power_curve := sin(downstroke_progress * PI)  # Smooth curve, peaks at 0.5
		lift_multiplier = power_curve
		thrust_multiplier = power_curve
		drag_multiplier = 0.2  # Minimal drag during powerful downstroke
	else:
		# Upstroke: minimal lift, wings folding - air resistance dominates
		var upstroke_progress := (flap_phase - 0.4) / 0.6  # 0 to 1 during upstroke
		lift_multiplier = 0.1 * (1.0 - upstroke_progress)  # Decays to zero
		thrust_multiplier = 0.0  # No forward thrust during recovery
		drag_multiplier = 1.0  # Full air resistance

	# === VERTICAL PHYSICS ===
	# Apply gravity (always pulling down)
	_vertical_velocity -= FLIGHT_GRAVITY * delta

	# Apply lift from wings (counteracts gravity during downstroke)
	_vertical_velocity += WING_LIFT_FORCE * lift_multiplier * delta

	# Height correction - gently steer towards target altitude
	var height_error := target_height - position.y
	var height_correction := clampf(height_error * 0.5, -5.0, 5.0)
	_vertical_velocity += height_correction * delta

	# Clamp vertical velocity to prevent extreme oscillation
	_vertical_velocity = clampf(_vertical_velocity, -15.0, 20.0)

	# === FORWARD PHYSICS ===
	# Apply forward thrust from wing downstroke (accelerate)
	_forward_speed_multiplier += WING_THRUST_FORCE * thrust_multiplier * delta

	# Apply air drag (decelerate back towards base speed)
	var speed_excess := _forward_speed_multiplier - 1.0
	_forward_speed_multiplier -= speed_excess * AIR_DRAG * drag_multiplier * delta

	# Clamp forward speed multiplier (0.7x to 1.5x base speed)
	_forward_speed_multiplier = clampf(_forward_speed_multiplier, 0.7, 1.5)


func _get_wing_flap_phase() -> float:
	## Get current phase of wing flap animation (0.0 to 1.0)
	## 0.0 = start of cycle (wings at top, about to push down)
	## 0.4 = end of downstroke (wings at bottom)
	## 1.0 = end of cycle (wings back at top)
	if not _anim_player or not _anim_player.is_playing():
		return 0.0

	if _anim_player.current_animation != anim_fly:
		return 0.0

	var anim_pos := _anim_player.current_animation_position
	var anim_length := _anim_player.current_animation_length

	if anim_length <= 0:
		return 0.0

	return fmod(anim_pos, anim_length) / anim_length


func _process_flying_to_land(delta: float) -> void:
	_play_animation(anim_fly, true)

	# Fly towards landing spot (approach from above)
	var approach_point := landing_spot + Vector3(0, 5, 0)
	var direction := (approach_point - position).normalized()
	var dist := position.distance_to(approach_point)

	# Apply flight physics with target height of approach point
	_apply_flight_physics(delta, approach_point.y)

	# Horizontal movement (speed varies with wing flaps)
	var current_speed := patrol_speed * _forward_speed_multiplier
	velocity.x = direction.x * current_speed
	velocity.z = direction.z * current_speed
	velocity.y = _vertical_velocity

	_face_direction(direction, delta)

	# Start landing descent when close
	if dist < 3.0:
		state = DragonState.LANDING
		_vertical_velocity = 0.0  # Reset for landing
		_forward_speed_multiplier = 1.0  # Reset for landing
		print("Dragon starting landing descent")
		if anim_land != &"":
			_play_animation(anim_land, false)


func _process_landing(delta: float) -> void:
	# Descend towards landing spot
	var target := landing_spot
	var direction := (target - position).normalized()
	var dist := position.distance_to(target)

	# Slow down as we approach
	var speed: float = clampf(dist * 0.5, 1.0, patrol_speed)
	velocity = direction * speed

	# Rotate to face landing direction
	_face_direction(direction, delta)

	# Check if landed
	if dist < 1.5:
		position = target
		velocity = Vector3.ZERO
		state = DragonState.WAIT
		wait_timer = 0.0
		print("Dragon landed! Waiting for ", wait_time, " seconds")
		_play_animation(anim_idle, true)


func _process_wait(delta: float) -> void:
	# Apply gravity when landed
	if not is_on_floor():
		velocity.y -= gravity * delta
	else:
		velocity.y = 0
		velocity.x = 0
		velocity.z = 0

	# Increment wait timer
	wait_timer += delta

	# Check for nearby player to attack
	if target_player and is_instance_valid(target_player):
		var dist := position.distance_to(target_player.global_position)

		# Face the player
		var dir_to_player := (target_player.global_position - position).normalized()
		_face_direction(dir_to_player, delta)

		if dist < attack_range:
			# Attack!
			_start_attack()
			return

	# Check if wait time complete
	if wait_timer >= wait_time:
		_start_takeoff()


func _start_attack() -> void:
	if state == DragonState.ATTACKING:
		return

	state = DragonState.ATTACKING
	print("Dragon attacking!")

	if anim_attack != &"":
		_play_animation(anim_attack, false)
	else:
		# No attack animation, just roar (return to wait after delay)
		await get_tree().create_timer(2.0).timeout
		state = DragonState.WAIT


func _process_attacking(delta: float) -> void:
	# Stay in place while attacking
	velocity = Vector3.ZERO

	# Keep facing player
	if target_player and is_instance_valid(target_player):
		var dir_to_player := (target_player.global_position - position).normalized()
		_face_direction(dir_to_player, delta)


func _start_takeoff() -> void:
	state = DragonState.TAKING_OFF
	_forward_speed_multiplier = 1.0  # Reset for takeoff
	print("Dragon taking off!")

	if anim_takeoff != &"":
		_play_animation(anim_takeoff, false)
	else:
		# No takeoff animation, use fly animation
		_play_animation(anim_fly, true)


func _process_takeoff(delta: float) -> void:
	_play_animation(anim_fly, true)

	# Apply flight physics - wings generate strong lift during takeoff
	_apply_flight_physics(delta, patrol_height)

	# Add extra upward thrust during takeoff
	_vertical_velocity += 10.0 * delta

	velocity = Vector3(0, _vertical_velocity, 0)

	# Check if high enough to resume patrol
	if position.y >= patrol_height * 0.8:
		state = DragonState.PATROL
		patrol_angle = 0.0  # Reset patrol angle
		print("Dragon resuming patrol")


func _face_direction(direction: Vector3, delta: float, enable_banking: bool = true) -> void:
	## Orient dragon to face direction with optional banking on turns
	## Banking creates natural flight appearance during circular patrol
	##
	## Dragon model orientation (Elder Scrolls Blades):
	## - Model faces -Z by default (needs 180° Y rotation to face +Z/forward)
	## - Model is upright (no Z rotation needed)
	## - Head pitches down ~60-70° in default pose (corrected by animation)
	if not _model or direction.length_squared() < 0.01:
		return

	var dir_normalized := direction.normalized()

	# Calculate yaw (Y-axis rotation) to face movement direction
	var target_yaw := atan2(dir_normalized.x, dir_normalized.z)

	# Calculate banking based on turn rate (change in direction)
	var bank_angle := 0.0
	if enable_banking and state == DragonState.PATROL:
		# Compute angular velocity (how fast we're turning)
		var cross := _last_direction.cross(dir_normalized)
		var turn_rate := cross.y  # Positive = turning right, Negative = turning left

		# Bank into the turn (negative roll for right turn, positive for left)
		var max_bank := deg_to_rad(30.0)  # Maximum bank angle
		bank_angle = clampf(-turn_rate * 20.0, -max_bank, max_bank)

		# Smooth the bank angle
		_current_bank_angle = lerp(_current_bank_angle, bank_angle, 3.0 * delta)
	else:
		# No banking when not in patrol (landing, taking off, etc.)
		_current_bank_angle = lerp(_current_bank_angle, 0.0, 5.0 * delta)

	# Calculate pitch based on vertical movement
	var pitch := 0.0
	if state == DragonState.PATROL or state == DragonState.FLYING_TO_LAND:
		# Pitch down when descending, up when ascending
		pitch = clampf(-dir_normalized.y * 0.5, deg_to_rad(-20.0), deg_to_rad(20.0))

	# Model orientation correction:
	# - Model faces +Z, so add -180° to yaw to face direction of travel
	# - No roll offset needed (model is upright)
	var y_offset := deg_to_rad(-180.0)

	# Build target rotation using euler angles
	# Euler order in Godot: YXZ (yaw first, then pitch, then roll)
	var target_euler := Vector3(pitch, target_yaw + y_offset, _current_bank_angle)

	# Smoothly interpolate rotation
	_model.rotation.x = lerp_angle(_model.rotation.x, target_euler.x, 5.0 * delta)
	_model.rotation.y = lerp_angle(_model.rotation.y, target_euler.y, 5.0 * delta)
	_model.rotation.z = lerp_angle(_model.rotation.z, target_euler.z, 5.0 * delta)

	# Store direction for next frame's turn rate calculation
	_last_direction = dir_normalized


func _play_animation(anim_name: StringName, loop: bool = false) -> void:
	if not _anim_player or anim_name == &"":
		return

	if _anim_player.current_animation == anim_name:
		return

	if _anim_player.has_animation(anim_name):
		_anim_player.play(anim_name)


func _on_animation_finished(anim_name: StringName) -> void:
	match state:
		DragonState.ATTACKING:
			# Attack finished, check if player still in range
			if target_player and is_instance_valid(target_player):
				var dist := position.distance_to(target_player.global_position)
				if dist < attack_range:
					# Attack again
					_play_animation(anim_attack, false)
				else:
					state = DragonState.WAIT
					wait_timer = 0.0  # Reset wait timer after attack
			else:
				state = DragonState.WAIT
				wait_timer = 0.0

		DragonState.LANDING:
			state = DragonState.WAIT
			wait_timer = 0.0
			_play_animation(anim_idle, true)

		DragonState.TAKING_OFF:
			state = DragonState.PATROL
			patrol_angle = 0.0
